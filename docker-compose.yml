# Define all the services (containers) that make up your application
services:
  # Backend service (e.g., Django, Flask, Node.js API)
  backend:
    # Build the backend image from the Dockerfile in the ./backend directory
    build: ./backend
    # Expose port 8000 on the host and map it to port 8000 in the container
    ports:
      - "8000:8000"
    # Load environment variables from the .env file
    env_file:
      - .env
    environment:
      DATABASE_URL: "postgresql+asyncpg://Buzzler_user:mahdi067279@db:5432/Buzzler"
      SMTP_HOST: "mailhog"
      SMTP_PORT: "1025"
      SMTP_USERNAME: ""
      SMTP_PASSWORD: ""
      SENDER_EMAIL: "noreply@buzzler.com"
      CELERY_BROKER_URL: "redis://redis:6379/0"
      REDIS_URL: "redis://redis:6379/0"
      CELERY_RESULT_BACKEND: "redis://redis:6379/1"
    # Wait for the db and redis services to be ready before starting
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_started
      # mailhog:
      #   condition: service_started
    # Mount the local ./backend folder into /app inside the container (for live code updates)
    volumes:
      - ./backend:/app

  # Frontend service (e.g., React, Vue, Angular)
  frontend:
    # Build the frontend image from the Dockerfile in the ./frontend directory
    build: ./frontend
    # Expose port 3000 on the host and map it to port 3000 in the container
    ports:
      - "3000:3000"
    # Mount the local ./frontend folder into /app inside the container
    volumes:
      - ./frontend:/app
      - /app/node_modules

  # Database service using PostgreSQL
  db:
    # Use the official postgres image, version 15
    image: postgres:16
    # Expose port 5433 on the host and map it to port 5432 in the container
    ports:
      - "5433:5432"
    # Set environment variables for the database (name, user, password)
    environment:
      POSTGRES_DB: Buzzler
      POSTGRES_USER: Buzzler_user
      POSTGRES_PASSWORD: mahdi067279
    # Store database data in a named volume for persistence
    volumes:
      - db-data:/var/lib/postgresql/data # Keeps data even if the container is removed
    # Add health check to ensure database is ready
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U Buzzler_user -d Buzzler"]
      interval: 5s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  celery:
    build: ./backend
    image: backend-celery
    command: ["celery", "-A", "app.celery.celery_app:celery_app", "worker", "--loglevel=info", "-Q", "audio_processing,video_processing,cleanup,import_tasks", "-c", "4"]
    env_file:
      - .env
    environment:
      - CELERY_BROKER_URL=redis://redis:6379/0
      - CELERY_RESULT_BACKEND=redis://redis:6379/1
      - REDIS_URL=redis://redis:6379/0
    depends_on:
      redis:
        condition: service_started
      db:
        condition: service_healthy
    volumes:
      - ./backend:/app

  # mailhog:
  #   image: mailhog/mailhog
  #   ports:
  #     - "1025:1025" # SMTP port
  #     - "8025:8025" # Web UI port
  #   healthcheck:
  #     test: ["CMD", "nc", "-z", "localhost", "1025"]
  #     interval: 10s
  #     timeout: 5s
  #     retries: 5

# Declare named volumes used by services above
volumes:
  db-data:
